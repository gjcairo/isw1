Object subclass: #Address	instanceVariableNames: 'id streetName streetNumber town zipCode province'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!Address methodsFor: 'identification' stamp: 'GustavoJuanCairo 11/16/2017 21:25'!isAt: aStreetName at: aStreetNumber	^ self streetName = aStreetName		and: [ self streetNumber = aStreetNumber ]! !!Address methodsFor: 'zip code' stamp: 'HernanWilkinson 10/28/2016 16:13'!zipCode	^zipCode! !!Address methodsFor: 'province' stamp: 'HernanWilkinson 10/28/2016 16:11'!province	^province! !!Address methodsFor: 'province' stamp: 'SebastianTaboh 11/9/2017 20:33'!initializeWithStreetName: aStreetName streetNumber: aStreetNumber town: aTownName zipCode: aZipCode province: aProvinceName	streetName := aStreetName.	streetNumber := aStreetNumber.	town := aTownName.	zipCode := aZipCode.	province := aProvinceName ! !!Address methodsFor: 'twon' stamp: 'HernanWilkinson 10/28/2016 16:12'!town	^town! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetName	^streetName ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetNumber	^streetNumber ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Address class	instanceVariableNames: ''!!Address class methodsFor: 'instance creation' stamp: 'SebastianTaboh 11/9/2017 20:32'!newWithStreetName: aStreetName streetNumber: aStreetNumber town: aTownName zipCode: aZipCode province: aProvinceName	^ self new initializeWithStreetName: aStreetName streetNumber: aStreetNumber town: aTownName zipCode: aZipCode province: aProvinceName ! !Object subclass: #CustomerImporter	instanceVariableNames: 'line inputStream lastProcessedCustomer record system'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!CustomerImporter methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/12/2017 23:21'!invalidCustomerRecordErrorMessage	^ 'El registro de cliente tiene una cantidad incorrecta de campos'! !!CustomerImporter methodsFor: 'importing' stamp: 'SebastianTaboh 11/13/2017 19:08'!isCustomerRecord	^ record first = 'C'! !!CustomerImporter methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/12/2017 23:25'!createAddressFromRecord	(record size = 6) ifFalse: [ self error: self invalidAddressRecordErrorMessage ].		^ Address		newWithStreetName: record second		streetNumber: record third asInteger		town: record fourth		zipCode: record fifth asInteger		province: record sixth! !!CustomerImporter methodsFor: 'importing' stamp: 'SebastianTaboh 11/9/2017 20:15'!processLine	self createRecordFromLine.	self parseRecord! !!CustomerImporter methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/12/2017 23:14'!parseRecord	self isCustomerRecord		ifTrue: [ ^ self parseCustomer ].	self isAddressRecord		ifTrue: [ ^ self parseAddress ].	self error: self invalidRecordDescriptorErrorMessage	! !!CustomerImporter methodsFor: 'importing' stamp: 'SebastianTaboh 11/13/2017 20:48'!initializeImportingFrom: anInputStream on: aSystem	inputStream := anInputStream.	system := aSystem! !!CustomerImporter methodsFor: 'importing' stamp: 'SebastianTaboh 11/13/2017 19:30'!value	[ self hasLineToProcess ] whileTrue:		[ self processLine ]! !!CustomerImporter methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/12/2017 23:21'!invalidAddressRecordErrorMessage	^ 'El registro de dirección tiene una cantidad incorrecta de campos'! !!CustomerImporter methodsFor: 'importing' stamp: 'SebastianTaboh 11/13/2017 20:46'!parseCustomer	lastProcessedCustomer := self createCustomerFromRecord.	system persist: lastProcessedCustomer! !!CustomerImporter methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/12/2017 23:25'!parseAddress	lastProcessedCustomer ifNil: [ self error: self addressWithoutCustomerErrorMessage ].	lastProcessedCustomer addAddress: self createAddressFromRecord! !!CustomerImporter methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/12/2017 23:08'!invalidRecordDescriptorErrorMessage	^ 'El descriptor de registro es inexistente: los únicos válidos son A para direcciones y C para clientes'! !!CustomerImporter methodsFor: 'importing' stamp: 'SebastianTaboh 11/13/2017 19:02'!createRecordFromLine	line := inputStream nextLine.	record := line substrings: {$,}! !!CustomerImporter methodsFor: 'importing' stamp: 'SebastianTaboh 11/13/2017 19:08'!isAddressRecord	^ record first = 'A'! !!CustomerImporter methodsFor: 'importing' stamp: 'SebastianTaboh 11/13/2017 19:02'!hasLineToProcess	^ inputStream atEnd not! !!CustomerImporter methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/12/2017 22:57'!addressWithoutCustomerErrorMessage	^ 'La primer linea del input stream debe ser un cliente, no una direccion'! !!CustomerImporter methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/20/2017 23:04'!createCustomerFromRecord	record size = 5		ifFalse: [ self error: self invalidCustomerRecordErrorMessage ].	^ Customer		newWithFirstName: record second		lastName: record third		id: (Identification ofType: record fourth number: record fifth)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CustomerImporter class	instanceVariableNames: ''!!CustomerImporter class methodsFor: 'instance creation' stamp: 'SebastianTaboh 11/13/2017 20:46'!importingFrom: inputStream on: aSystem	^ self new initializeImportingFrom: inputStream on: aSystem! !TestCase subclass: #CustomerImporterTest	instanceVariableNames: 'inputStream customerImporter system'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!CustomerImporterTest methodsFor: 'importing' stamp: 'SebastianTaboh 11/9/2017 20:52'!invalidTestDataNoCustomerOnFirstLine	^ 'A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos AiresC,Juan,Perez,C,23-25666777-9A,Alem,1122,CABA,1001,CABA'! !!CustomerImporterTest methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/12/2017 23:09'!invalidTestDataCustomerRecordWithMoreThanFiveFields	^ 'C,Pepe,Sanchez,D,22333444,BlaA,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos AiresC,Juan,Perez,C,23-25666777-9A,Alem,1122,CABA,1001,CABA'! !!CustomerImporterTest methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/12/2017 23:08'!invalidTestDataAddressRecordWithLessThanSixFields	^ 'C,Pepe,Sanchez,D,22333444A,San Martin,3322,Olivos,1636A,Maipu,888,Florida,1122,Buenos AiresC,Juan,Perez,C,23-25666777-9A,Alem,1122,CABA,1001,CABA'! !!CustomerImporterTest methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/12/2017 23:04'!invalidTestDataDescriptorCFollowedByMoreLetters	^ 'CC,Pepe,Sanchez,D,22333444A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos AiresC,Juan,Perez,C,23-25666777-9A,Alem,1122,CABA,1001,CABA'! !!CustomerImporterTest methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/16/2017 21:03'!importCustomers	customerImporter := CustomerImporter		importingFrom: inputStream		on: system.	customerImporter value.	inputStream close! !!CustomerImporterTest methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/12/2017 23:04'!invalidTestDataDescriptorAFollowedByMoreLetters	^ 'C,Pepe,Sanchez,D,22333444AA,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos AiresC,Juan,Perez,C,23-25666777-9A,Alem,1122,CABA,1001,CABA'! !!CustomerImporterTest methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/12/2017 23:15'!invalidTestDataNonexistentLineDescriptor	^ 'J,Pepe,Sanchez,D,22333444A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos AiresC,Juan,Perez,C,23-25666777-9A,Alem,1122,CABA,1001,CABA'! !!CustomerImporterTest methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/12/2017 23:08'!invalidTestDataCustomerRecordWithLessThanFiveFields	^ 'C,Pepe,Sanchez,DA,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos AiresC,Juan,Perez,C,23-25666777-9A,Alem,1122,CABA,1001,CABA'! !!CustomerImporterTest methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/20/2017 23:12'!setUp	system := Environment current createCustomerSystem.	system startUp! !!CustomerImporterTest methodsFor: 'importing' stamp: 'SebastianTaboh 11/13/2017 20:38'!tearDown	system shutDown! !!CustomerImporterTest methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/12/2017 23:08'!invalidTestDataAddressRecordWithMoreThanSixFields	^ 'C,Pepe,Sanchez,D,22333444A,San Martin,3322,Olivos,1636,BsAs,BlaA,Maipu,888,Florida,1122,Buenos AiresC,Juan,Perez,C,23-25666777-9A,Alem,1122,CABA,1001,CABA'! !!CustomerImporterTest methodsFor: 'importing' stamp: 'SebastianTaboh 11/9/2017 20:50'!validTestData	^ 'C,Pepe,Sanchez,D,22333444A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos AiresC,Juan,Perez,C,23-25666777-9A,Alem,1122,CABA,1001,CABA'! !!CustomerImporterTest methodsFor: 'tests' stamp: 'GustavoJuanCairo 11/16/2017 21:03'!test02ImportingCustomersFromFileWithoutCustomerOnFirstLineFails	inputStream := ReadStream		on: self invalidTestDataNoCustomerOnFirstLine.	self		should: [ self importCustomers ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anException | 			self				assert: anException messageText				equals: customerImporter addressWithoutCustomerErrorMessage.			self assertCustomersNotImported ]! !!CustomerImporterTest methodsFor: 'tests' stamp: 'GustavoJuanCairo 11/16/2017 21:03'!test06CannotImportCustomerRecordWithLessThanFiveFields	inputStream := ReadStream		on: self invalidTestDataCustomerRecordWithLessThanFiveFields.	self		should: [ self importCustomers ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anException | 			self				assert: anException messageText				equals: customerImporter invalidCustomerRecordErrorMessage.			self assertCustomersNotImported ]! !!CustomerImporterTest methodsFor: 'tests' stamp: 'GustavoJuanCairo 11/12/2017 23:10'!assertCustomersNotImported	self assert: (self numberOfCustomers) equals: 0! !!CustomerImporterTest methodsFor: 'tests' stamp: 'SebastianTaboh 11/13/2017 20:41'!alwaysImportedCustomer	^ system allCustomers first! !!CustomerImporterTest methodsFor: 'tests' stamp: 'GustavoJuanCairo 11/20/2017 22:47'!assertJuanPerezImportedCorrectly	| customer identification anAddress |	identification := Identification ofType: 'C' number: '23-25666777-9'.	customer := system		customerIdentifiedAs: identification		ifNone: [ self fail ].	self assert: customer firstName equals: 'Juan'.	self assert: customer lastName equals: 'Perez'.	self assert: (customer isIdentifiedAs: identification).	anAddress := customer addressAt: 'Alem' at: 1122.	self assert: anAddress streetName equals: 'Alem'.	self assert: anAddress streetNumber equals: 1122.	self assert: anAddress town equals: 'CABA'.	self assert: anAddress zipCode equals: 1001.	self assert: anAddress province equals: 'CABA'! !!CustomerImporterTest methodsFor: 'tests' stamp: 'GustavoJuanCairo 11/20/2017 22:46'!assertPepeSanchezImportedCorrectly	| customer anAddress identification |	identification := Identification ofType: 'D' number: '22333444'.	customer := system		customerIdentifiedAs: identification		ifNone: [ self fail ].	self assert: customer firstName equals: 'Pepe'.	self assert: customer lastName equals: 'Sanchez'.	self assert: (customer isIdentifiedAs: identification).	anAddress := customer addressAt: 'San Martin' at: 3322.	self assert: anAddress streetName equals: 'San Martin'.	self assert: anAddress streetNumber equals: 3322.	self assert: anAddress town equals: 'Olivos'.	self assert: anAddress zipCode equals: 1636.	self assert: anAddress province equals: 'BsAs'.	anAddress := customer addressAt: 'Maipu' at: 888.	self assert: anAddress streetName equals: 'Maipu'.	self assert: anAddress streetNumber equals: 888.	self assert: anAddress town equals: 'Florida'.	self assert: anAddress zipCode equals: 1122.	self assert: anAddress province equals: 'Buenos Aires'! !!CustomerImporterTest methodsFor: 'tests' stamp: 'GustavoJuanCairo 11/16/2017 21:03'!test04ImportingCustomersFromFileWithCLineDescriptorWithMoreCharactersFails	inputStream := ReadStream		on: self invalidTestDataDescriptorCFollowedByMoreLetters.	self		should: [ self importCustomers ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anException | 			self				assert: anException messageText				equals: customerImporter invalidRecordDescriptorErrorMessage.			self assertCustomersNotImported ]! !!CustomerImporterTest methodsFor: 'tests' stamp: 'GustavoJuanCairo 11/16/2017 21:03'!test05ImportingCustomersFromFileWithALineDescriptorWithMoreCharactersFails	inputStream := ReadStream		on: self invalidTestDataDescriptorAFollowedByMoreLetters.	self		should: [ self importCustomers ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anException | 			self				assert: anException messageText				equals: customerImporter invalidRecordDescriptorErrorMessage.			self assert: self numberOfCustomers equals: 1.			self assert: self alwaysImportedCustomer addressesIsEmpty ]! !!CustomerImporterTest methodsFor: 'tests' stamp: 'GustavoJuanCairo 11/16/2017 21:03'!test9CannotImportAddressRecordWithMoreThanSixFields	inputStream := ReadStream		on: self invalidTestDataAddressRecordWithMoreThanSixFields.	self		should: [ self importCustomers ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anException | 			self				assert: anException messageText				equals: customerImporter invalidAddressRecordErrorMessage.			self assert: self numberOfCustomers equals: 1.			self assert: self alwaysImportedCustomer addressesIsEmpty ]! !!CustomerImporterTest methodsFor: 'tests' stamp: 'GustavoJuanCairo 11/16/2017 21:03'!test01ImportCustomersMapsCustomersCorrectly	inputStream := ReadStream on: self validTestData.	self importCustomers.	self assert: self numberOfCustomers equals: 2.	self assertPepeSanchezImportedCorrectly.	self assertJuanPerezImportedCorrectly! !!CustomerImporterTest methodsFor: 'tests' stamp: 'GustavoJuanCairo 11/16/2017 21:03'!test08CannotImportAddressRecordWithLessThanSixFields	inputStream := ReadStream		on: self invalidTestDataAddressRecordWithLessThanSixFields.	self		should: [ self importCustomers ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anException | 			self				assert: anException messageText				equals: customerImporter invalidAddressRecordErrorMessage.			self assert: self numberOfCustomers equals: 1.			self assert: self alwaysImportedCustomer addressesIsEmpty ]! !!CustomerImporterTest methodsFor: 'tests' stamp: 'GustavoJuanCairo 11/16/2017 21:03'!test03ImportingCustomersFromFileWithNonexistentSingleCharacterLineDescriptorFails	inputStream := ReadStream		on: self invalidTestDataNonexistentLineDescriptor.	self		should: [ self importCustomers ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anException | 			self				assert: anException messageText				equals: customerImporter invalidRecordDescriptorErrorMessage.			self assertCustomersNotImported ]! !!CustomerImporterTest methodsFor: 'tests' stamp: 'SebastianTaboh 11/13/2017 20:41'!numberOfCustomers	^ system allCustomers size! !!CustomerImporterTest methodsFor: 'tests' stamp: 'GustavoJuanCairo 11/16/2017 21:03'!test07CannotImportCustomerRecordWithMoreThanFiveFields	inputStream := ReadStream		on: self invalidTestDataCustomerRecordWithMoreThanFiveFields.	self		should: [ self importCustomers ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anException | 			self				assert: anException messageText				equals: customerImporter invalidCustomerRecordErrorMessage.			self assertCustomersNotImported ]! !Object subclass: #ERPSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!ERPSystem methodsFor: 'persistance' stamp: 'GustavoJuanCairo 11/20/2017 23:18'!shutDown	self subclassResponsibility ! !!ERPSystem methodsFor: 'persistance' stamp: 'GustavoJuanCairo 11/20/2017 23:18'!persist: aCustomer	self subclassResponsibility ! !!ERPSystem methodsFor: 'persistance' stamp: 'GustavoJuanCairo 11/20/2017 23:18'!startUp	self subclassResponsibility ! !ERPSystem subclass: #CustomerSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!CustomerSystem methodsFor: 'persistance' stamp: 'SebastianTaboh 11/13/2017 21:11'!allCustomers	self subclassResponsibility ! !!CustomerSystem methodsFor: 'persistance' stamp: 'GustavoJuanCairo 11/20/2017 23:08'!customerIdentifiedAs: anId ifNone: anObject 	self subclassResponsibility ! !Object subclass: #Environment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!Environment methodsFor: 'as yet unclassified' stamp: 'GustavoJuanCairo 11/20/2017 19:41'!createSupplierSystem	self subclassResponsibility ! !!Environment methodsFor: 'as yet unclassified' stamp: 'SebastianTaboh 11/13/2017 21:20'!createCustomerSystem	self subclassResponsibility ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Environment class	instanceVariableNames: ''!!Environment class methodsFor: 'testing' stamp: 'SebastianTaboh 11/13/2017 21:46'!isCurrent	self subclassResponsibility ! !!Environment class methodsFor: 'accessing' stamp: 'SebastianTaboh 11/13/2017 21:38'!noCurrentEnvironmentErrorMessage	^ 'No hay un entorno vigente actualmente'! !!Environment class methodsFor: 'accessing' stamp: 'SebastianTaboh 11/13/2017 21:45'!current	^ self allSubclasses		detect: [ :aSubclass | aSubclass isCurrent ]		ifFound: [ :aSubclass | aSubclass new ]		ifNone: [ self error: self noCurrentEnvironmentErrorMessage ]		! !Environment subclass: #DevelopmentEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!DevelopmentEnvironment methodsFor: 'as yet unclassified' stamp: 'GustavoJuanCairo 11/16/2017 21:50'!createSupplierSystem	^ TransientSupplierSystem new! !!DevelopmentEnvironment methodsFor: 'as yet unclassified' stamp: 'SebastianTaboh 11/13/2017 21:43'!createCustomerSystem	^ TransientCustomerSystem new! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DevelopmentEnvironment class	instanceVariableNames: ''!!DevelopmentEnvironment class methodsFor: 'testing' stamp: 'GustavoJuanCairo 11/20/2017 23:05'!isCurrent	^ true! !Object subclass: #Identification	instanceVariableNames: 'type number'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!Identification methodsFor: 'testing' stamp: 'GustavoJuanCairo 11/20/2017 22:44'!isOfType: anIdType number: anIdNumber	^ (type = anIdType) and: [ number = anIdNumber ]! !!Identification methodsFor: 'accessing' stamp: 'GustavoJuanCairo 11/20/2017 20:52'!number	^ number copy! !!Identification methodsFor: 'accessing' stamp: 'GustavoJuanCairo 11/20/2017 20:52'!type	^ type copy! !!Identification methodsFor: 'Accessing' stamp: 'GustavoJuanCairo 11/20/2017 21:13'!= anotherId	^ number = (anotherId number) and: [ type = (anotherId type) ]! !!Identification methodsFor: 'Accessing' stamp: 'GustavoJuanCairo 11/20/2017 21:19'!initializeWithType: anIdType number: anIdNumber	type := anIdType.	number := anIdNumber ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Identification class	instanceVariableNames: ''!!Identification class methodsFor: 'as yet unclassified' stamp: 'GustavoJuanCairo 11/20/2017 21:20'!ofType: anIdType number: anIdNumber	^ self new initializeWithType: anIdType number: anIdNumber! !Environment subclass: #IntegrationEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!IntegrationEnvironment methodsFor: 'as yet unclassified' stamp: 'GustavoJuanCairo 11/16/2017 21:50'!createSupplierSystem	^ PersistentSupplierSystem new! !!IntegrationEnvironment methodsFor: 'as yet unclassified' stamp: 'SebastianTaboh 11/13/2017 21:43'!createCustomerSystem	^ PersistentCustomerSystem new! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!IntegrationEnvironment class	instanceVariableNames: ''!!IntegrationEnvironment class methodsFor: 'testing' stamp: 'GustavoJuanCairo 11/20/2017 23:05'!isCurrent	^ false! !Object subclass: #Party	instanceVariableNames: 'id identification addresses'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!Party methodsFor: 'addresses' stamp: 'GustavoJuanCairo 11/16/2017 19:08'!addAddress: anAddress 	addresses add: anAddress ! !!Party methodsFor: 'addresses' stamp: 'GustavoJuanCairo 11/16/2017 19:08'!addressesIsEmpty	^ addresses isEmpty ! !!Party methodsFor: 'addresses' stamp: 'GustavoJuanCairo 11/20/2017 21:10'!initializeWithId: anId	addresses := OrderedCollection new.	identification := anId! !!Party methodsFor: 'Accessing' stamp: 'GustavoJuanCairo 11/20/2017 21:12'!isIdentifiedAs: anId	^ identification = anId! !!Party methodsFor: 'identification' stamp: 'GustavoJuanCairo 11/16/2017 21:28'!invalidAddressErrorMessage	self subclassResponsibility ! !!Party methodsFor: 'identification' stamp: 'GustavoJuanCairo 11/20/2017 20:39'!addressAt: aStreetName at: aStreetNumber	^ addresses		detect: [ :address | address isAt: aStreetName at: aStreetNumber ]		ifNone: [ self error: self invalidAddressErrorMessage ]! !Party subclass: #Customer	instanceVariableNames: 'firstName lastName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!Customer methodsFor: 'name' stamp: 'GustavoJuanCairo 11/16/2017 19:14'!firstName		^ firstName copy! !!Customer methodsFor: 'name' stamp: 'GustavoJuanCairo 11/16/2017 19:14'!lastName	^ lastName copy! !!Customer methodsFor: 'addresses' stamp: 'GustavoJuanCairo 11/20/2017 21:15'!initializeWithFirstName: aFirstName lastName: aLastName id: anId	super initializeWithId: anId.	firstName := aFirstName.	lastName := aLastName! !!Customer methodsFor: 'addresses' stamp: 'GustavoJuanCairo 11/16/2017 21:29'!invalidAddressErrorMessage	^ 'La direccion no pertenece al cliente'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Customer class	instanceVariableNames: ''!!Customer class methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/20/2017 21:15'!newWithFirstName: aFirstName lastName: aLastName id: anId	^ self new		initializeWithFirstName: aFirstName		lastName: aLastName		id: anId! !CustomerSystem subclass: #PersistentCustomerSystem	instanceVariableNames: 'session'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!PersistentCustomerSystem methodsFor: 'importing' stamp: 'SebastianTaboh 11/13/2017 20:17'!addressMapping	^ ClassMapping		withDefaultTableNameFor: Address		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #streetName)				with: (EmbededMapping withDefaultFieldNameFor: #streetNumber)				with: (EmbededMapping withDefaultFieldNameFor: #town)				with: (EmbededMapping withDefaultFieldNameFor: #zipCode)				with: (EmbededMapping withDefaultFieldNameFor: #province))! !!PersistentCustomerSystem methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/16/2017 18:26'!startUp	session open.	session beginTransaction! !!PersistentCustomerSystem methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/16/2017 18:26'!shutDown	session commit.	session close! !!PersistentCustomerSystem methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/20/2017 22:36'!customerMapping	^ ClassMapping		withDefaultTableNameFor: Customer		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #firstName)				with: (EmbededMapping withDefaultFieldNameFor: #lastName)				with: (EmbededMapping withDefaultFieldNameFor: #identification)				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address))! !!PersistentCustomerSystem methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/16/2017 18:26'!initializeSession	session := DataBaseSession		for: (Array with: self addressMapping with: self customerMapping)! !!PersistentCustomerSystem methodsFor: 'importing' stamp: 'SebastianTaboh 11/13/2017 20:59'!persist: aCustomer	session persist: aCustomer ! !!PersistentCustomerSystem methodsFor: 'importing' stamp: 'SebastianTaboh 11/13/2017 20:29'!initialize	super initialize.	self initializeSession ! !!PersistentCustomerSystem methodsFor: 'tests' stamp: 'GustavoJuanCairo 11/16/2017 18:26'!allCustomers	^ session selectAllOfType: Customer! !!PersistentCustomerSystem methodsFor: 'tests' stamp: 'GustavoJuanCairo 11/20/2017 22:33'!customerIdentifiedAs: anId ifNone: noneBlock	| customers |	customers := session		select: [ :aCustomer | aCustomer isIdentifiedAs: anId ]		ofType: Customer.	customers size < 1		ifTrue: noneBlock.	^ customers anyOne! !Party subclass: #Supplier	instanceVariableNames: 'customers name'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!Supplier methodsFor: 'initialization' stamp: 'GustavoJuanCairo 11/16/2017 21:29'!invalidCustomerErrorMessage	^ 'El cliente no pertenece al proveedor'! !!Supplier methodsFor: 'initialization' stamp: 'GustavoJuanCairo 11/16/2017 21:29'!invalidAddressErrorMessage	^ 'La direccion no pertenece al proveedor'! !!Supplier methodsFor: 'initialization' stamp: 'GustavoJuanCairo 11/20/2017 21:16'!customerIdentifiedAs: anId	^ customers		detect: [ :aCustomer | aCustomer isIdentifiedAs: anId ]		ifNone: [ self error: self invalidCustomerErrorMessage ]! !!Supplier methodsFor: 'initialization' stamp: 'GustavoJuanCairo 11/20/2017 21:16'!initializeWithName: aName id: anId	super initializeWithId: anId.	customers := OrderedCollection new.	name := aName! !!Supplier methodsFor: 'initialization' stamp: 'GustavoJuanCairo 11/16/2017 19:21'!name	^ name copy! !!Supplier methodsFor: 'initialization' stamp: 'GustavoJuanCairo 11/20/2017 20:31'!customersIsEmpty	^ customers isEmpty ! !!Supplier methodsFor: 'initialization' stamp: 'GustavoJuanCairo 11/16/2017 20:39'!addCustomer: aCustomer	customers add: aCustomer ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Supplier class	instanceVariableNames: ''!!Supplier class methodsFor: 'instance creation' stamp: 'GustavoJuanCairo 11/20/2017 21:16'!newWithName: aName id: anId	^ self new initializeWithName: aName id: anId! !Object subclass: #SupplierImporter	instanceVariableNames: 'line inputStream record lastProcessedSupplier customerSystem supplierSystem'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!SupplierImporter methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/20/2017 23:02'!createSupplierFromRecord	record size = 4		ifFalse: [ self error: self invalidSupplierRecordErrorMessage ].	^ Supplier newWithName: record second id: (Identification ofType: record third number: record fourth)! !!SupplierImporter methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/16/2017 20:26'!createRecordFromLine	line := inputStream nextLine.	record := line substrings: {$,}! !!SupplierImporter methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/16/2017 20:36'!invalidRecordDescriptorErrorMessage	^ 'El descriptor de registro es inexistente: los únicos válidos son S para proveedor, NC para nuevos clientes, EC para clientes existentes y A para direcciones'! !!SupplierImporter methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/16/2017 20:26'!value	[ self hasLineToProcess ] whileTrue:		[ self processLine ]! !!SupplierImporter methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/16/2017 20:26'!invalidAddressRecordErrorMessage	^ 'El registro de dirección tiene una cantidad incorrecta de campos'! !!SupplierImporter methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/20/2017 19:48'!initializeImportingFrom: anInputStream on: aSupplierSystem with: aCustomerSystem	inputStream := anInputStream.	supplierSystem := aSupplierSystem.	customerSystem := aCustomerSystem ! !!SupplierImporter methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/16/2017 21:47'!invalidExistingCustomerRecordErrorMessage	^ 'El registro de cliente existente tiene una cantidad incorrecta de campos'! !!SupplierImporter methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/20/2017 23:03'!createCustomerFromRecord	record size = 5		ifFalse: [ self error: self invalidNewCustomerRecordErrorMessage ].	^ Customer		newWithFirstName: record second		lastName: record third		id: (Identification ofType: record fourth number: record fifth)! !!SupplierImporter methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/16/2017 20:45'!isSupplierRecord	^ record first = 'S'! !!SupplierImporter methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/16/2017 20:36'!isNewCustomerRecord	^ record first = 'NC'! !!SupplierImporter methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/16/2017 21:47'!invalidNewCustomerRecordErrorMessage	^ 'El registro de nuevo cliente tiene una cantidad incorrecta de campos'! !!SupplierImporter methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/16/2017 21:42'!parseRecord	self isSupplierRecord		ifTrue: [ ^ self parseSupplier ].	self isNewCustomerRecord		ifTrue: [ ^ self parseNewCustomer ].	self isExistingCustomerRecord		ifTrue: [ ^ self addExistingCustomer ].	self isAddressRecord		ifTrue: [ ^ self parseAddress ].	self error: self invalidRecordDescriptorErrorMessage	! !!SupplierImporter methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/16/2017 20:37'!parseAddress	lastProcessedSupplier ifNil: [ self error: self addressWithoutSupplierErrorMessage ].	lastProcessedSupplier addAddress: self createAddressFromRecord! !!SupplierImporter methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/16/2017 20:36'!isExistingCustomerRecord	^ record first = 'EC'! !!SupplierImporter methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/20/2017 19:37'!parseSupplier	lastProcessedSupplier := self createSupplierFromRecord.	supplierSystem persist: lastProcessedSupplier! !!SupplierImporter methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/20/2017 19:39'!invalidExistingCustomerErrorMessage	^ 'El cliente especificado como existente no existe'! !!SupplierImporter methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/16/2017 20:34'!invalidSupplierRecordErrorMessage			^ 'El registro de proveedor tiene una cantidad incorrecta de campos'! !!SupplierImporter methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/16/2017 20:46'!customerWithoutSupplierErrorMessage	^ 'La primer linea del input stream debe ser un proveedor, no un cliente'! !!SupplierImporter methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/20/2017 22:56'!addExistingCustomer	lastProcessedSupplier		ifNil: [ self error: self customerWithoutSupplierErrorMessage ].	record size = 3		ifFalse: [ self error: self invalidExistingCustomerRecordErrorMessage ].	lastProcessedSupplier		addCustomer:			(customerSystem				customerIdentifiedAs: (Identification ofType: record second number: record third)				ifNone: [ self error: self invalidExistingCustomerErrorMessage ])! !!SupplierImporter methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/16/2017 21:42'!parseNewCustomer	lastProcessedSupplier ifNil: [ self error: self customerWithoutSupplierErrorMessage ].	lastProcessedSupplier addCustomer: self createCustomerFromRecord! !!SupplierImporter methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/16/2017 20:26'!processLine	self createRecordFromLine.	self parseRecord! !!SupplierImporter methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/16/2017 20:26'!hasLineToProcess	^ inputStream atEnd not! !!SupplierImporter methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/16/2017 20:26'!isAddressRecord	^ record first = 'A'! !!SupplierImporter methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/16/2017 20:26'!createAddressFromRecord	(record size = 6) ifFalse: [ self error: self invalidAddressRecordErrorMessage ].		^ Address		newWithStreetName: record second		streetNumber: record third asInteger		town: record fourth		zipCode: record fifth asInteger		province: record sixth! !!SupplierImporter methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/16/2017 20:46'!addressWithoutSupplierErrorMessage	^ 'La primer linea del input stream debe ser un proveedor, no una direccion'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SupplierImporter class	instanceVariableNames: ''!!SupplierImporter class methodsFor: 'instance creation' stamp: 'GustavoJuanCairo 11/20/2017 19:48'!importingFrom: inputStream on: aSupplierSystem with: aCustomerSystem	^ self new		initializeImportingFrom: inputStream		on: aSupplierSystem		with: aCustomerSystem! !TestCase subclass: #SupplierImporterTest	instanceVariableNames: 'inputStream supplierImporter supplierSystem customerSystem customerImporter'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!SupplierImporterTest methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/20/2017 20:22'!invalidTestDataSupplierRecordWithLessThanFourFields	^ 'S,Supplier1,DNC,Pepe,Sanchez,D,123456EC,D,5456774A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos Aires'! !!SupplierImporterTest methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/20/2017 20:32'!validTestData	^ 'S,Supplier1,D,123NC,Pepe,Sanchez,D,22333444EC,D,5456774A,San Martin,3322,Olivos,1636,BsAsS,Supplier2,D,456A,Maipu,888,Florida,1122,Buenos Aires'! !!SupplierImporterTest methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/20/2017 20:44'!invalidTestDataExistingCustomerRecordWithMoreThanThreeFields	^ 'S,Supplier1,D,1235EC,D,12325,ASFNC,Pepe,Sanchez,D,123456A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos Aires'! !!SupplierImporterTest methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/16/2017 21:11'!invalidTestDataNewCustomerRecordWithLessThanFiveFields	^ 'S,Supplier1,D,123NC,Pepe,Sanchez,DEC,D,5456774A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos Aires'! !!SupplierImporterTest methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/20/2017 20:07'!invalidTestDataNoSupplierOnFirstLine	^ 'NC,Pepe,Sanchez,D,22333444EC,D,5456774A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos Aires'! !!SupplierImporterTest methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/20/2017 20:36'!invalidTestDataExistingCustomerRecordWithLessThanThreeFields	^ 'S,Supplier1,D,2134EC,DNC,Pepe,Sanchez,D,123456A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos Aires'! !!SupplierImporterTest methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/20/2017 20:22'!invalidTestDataSupplierRecordWithMoreThanFourFields	^ 'S,Supplier1,D,12432,ASFNC,Pepe,Sanchez,D,123456EC,D,5456774A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos Aires'! !!SupplierImporterTest methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/20/2017 19:46'!importSuppliers	supplierImporter := SupplierImporter		importingFrom: inputStream		on: supplierSystem		with: customerSystem.	supplierImporter value.	inputStream close! !!SupplierImporterTest methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/20/2017 19:52'!validExistingCustomerTestData	^ 'C,Juan,Martin,D,5456774A,San Martin,3322,Olivos,1636,BsAs'! !!SupplierImporterTest methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/20/2017 20:16'!invalidTestDataNonexistentLineDescriptor	^ 'SX,Supplier1,D,123NC,Pepe,Sanchez,D,22333444EC,D,5456774A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos Aires'! !!SupplierImporterTest methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/20/2017 19:43'!setUp	supplierSystem := Environment current createSupplierSystem.	supplierSystem startUp.	customerSystem := Environment current createCustomerSystem.	customerSystem startUp! !!SupplierImporterTest methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/20/2017 19:43'!tearDown	supplierSystem shutDown! !!SupplierImporterTest methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/20/2017 19:51'!importExistingCustomer	customerImporter := CustomerImporter		importingFrom: inputStream		on: customerSystem.	customerImporter value.	inputStream close! !!SupplierImporterTest methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/16/2017 21:12'!invalidTestDataNewCustomerRecordWithMoreThanFiveFields	^ 'S,Supplier1,D,123NC,Pepe,Sanchez,D,22333444,ABCEC,D,5456774A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos Aires'! !!SupplierImporterTest methodsFor: 'tests' stamp: 'GustavoJuanCairo 11/20/2017 20:45'!test09CannotImportNewCustomerRecordWithMoreThanFiveFields	inputStream := ReadStream		on: self invalidTestDataNewCustomerRecordWithMoreThanFiveFields.	self		should: [ self importSuppliers ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anException | 			self assert: anException messageText equals: supplierImporter invalidNewCustomerRecordErrorMessage.			self assert: self numberOfSuppliers equals: 1.			self assert: self alwaysImportedSupplier customersIsEmpty ]! !!SupplierImporterTest methodsFor: 'tests' stamp: 'GustavoJuanCairo 11/20/2017 20:44'!test08CannotImportNewCustomerRecordWithLessThanFiveFields	inputStream := ReadStream		on: self invalidTestDataNewCustomerRecordWithLessThanFiveFields.	self		should: [ self importSuppliers ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anException | 			self assert: anException messageText equals: supplierImporter invalidNewCustomerRecordErrorMessage.			self assert: self numberOfSuppliers equals: 1.			self assert: self alwaysImportedSupplier customersIsEmpty ]! !!SupplierImporterTest methodsFor: 'tests' stamp: 'GustavoJuanCairo 11/20/2017 20:42'!test07CannotImportExistingCustomerRecordWithMoreThanThreeFields	inputStream := ReadStream		on: self invalidTestDataExistingCustomerRecordWithMoreThanThreeFields.	self		should: [ self importSuppliers ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anException | 			self assert: anException messageText equals: supplierImporter invalidExistingCustomerRecordErrorMessage.			self assert: self numberOfSuppliers equals: 1.			self assert: self alwaysImportedSupplier customersIsEmpty ]! !!SupplierImporterTest methodsFor: 'tests' stamp: 'GustavoJuanCairo 11/20/2017 20:12'!test02ImportingSuppliersFromFileWithoutSupplierOnFirstLineFails	inputStream := ReadStream		on: self invalidTestDataNoSupplierOnFirstLine.	self		should: [ self importSuppliers ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anException | 			self assert: anException messageText equals: supplierImporter customerWithoutSupplierErrorMessage.			self assertSuppliersNotImported ]! !!SupplierImporterTest methodsFor: 'tests' stamp: 'GustavoJuanCairo 11/20/2017 22:50'!assertSupplier2ImportedCorrectly	| supplier anAddress identification |	identification := Identification ofType: 'D' number: '456'.	supplier := supplierSystem		supplierIdentifiedAs: identification		ifNone: [ self fail ].	self assert: supplier name equals: 'Supplier2'.	self assert: (supplier isIdentifiedAs: identification).	self assert: supplier customersIsEmpty.	anAddress := supplier addressAt: 'Maipu' at: 888.	self assert: (anAddress isAt: 'Maipu' at: 888).	self assert: anAddress town equals: 'Florida'.	self assert: anAddress zipCode equals: 1122.	self assert: anAddress province equals: 'Buenos Aires'! !!SupplierImporterTest methodsFor: 'tests' stamp: 'GustavoJuanCairo 11/20/2017 19:43'!alwaysImportedSupplier	^ supplierSystem allSuppliers first! !!SupplierImporterTest methodsFor: 'tests' stamp: 'GustavoJuanCairo 11/20/2017 19:43'!numberOfSuppliers	^ supplierSystem allSuppliers size! !!SupplierImporterTest methodsFor: 'tests' stamp: 'GustavoJuanCairo 11/20/2017 20:25'!test04CannotImportSupplierRecordWithLessThanFourFields	inputStream := ReadStream		on: self invalidTestDataSupplierRecordWithLessThanFourFields.	self		should: [ self importSuppliers ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anException | 			self assert: anException messageText equals: supplierImporter invalidSupplierRecordErrorMessage.			self assertSuppliersNotImported ]! !!SupplierImporterTest methodsFor: 'tests' stamp: 'GustavoJuanCairo 11/20/2017 20:13'!test03ImportingCustomersFromFileWithNonexistentSingleCharacterLineDescriptorFails	inputStream := ReadStream		on: self invalidTestDataNonexistentLineDescriptor.	self		should: [ self importSuppliers ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anException | 			self assert: anException messageText equals: supplierImporter invalidRecordDescriptorErrorMessage.			self assertSuppliersNotImported ]! !!SupplierImporterTest methodsFor: 'tests' stamp: 'GustavoJuanCairo 11/20/2017 20:25'!test05CannotImportSupplierRecordWithMoreThanFourFields	inputStream := ReadStream		on: self invalidTestDataSupplierRecordWithMoreThanFourFields.	self		should: [ self importSuppliers ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anException | 			self assert: anException messageText equals: supplierImporter invalidSupplierRecordErrorMessage.			self assertSuppliersNotImported ]! !!SupplierImporterTest methodsFor: 'tests' stamp: 'GustavoJuanCairo 11/20/2017 20:34'!test01ImportSuppliersMapsSuppliersCorrectly	inputStream := ReadStream on: self validExistingCustomerTestData.	self importExistingCustomer.	inputStream := ReadStream on: self validTestData.	self importSuppliers.		self assert: self numberOfSuppliers equals: 2.	self assertSupplier1ImportedCorrectly. 	self assertSupplier2ImportedCorrectly ! !!SupplierImporterTest methodsFor: 'tests' stamp: 'GustavoJuanCairo 11/20/2017 20:35'!test06CannotImportExistingCustomerRecordWithLessThanThreeFields	inputStream := ReadStream		on: self invalidTestDataExistingCustomerRecordWithLessThanThreeFields.	self		should: [ self importSuppliers ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anException | 			self assert: anException messageText equals: supplierImporter invalidExistingCustomerRecordErrorMessage.			self assert: self numberOfSuppliers equals: 1.			self assert: self alwaysImportedSupplier customersIsEmpty ]! !!SupplierImporterTest methodsFor: 'tests' stamp: 'GustavoJuanCairo 11/20/2017 22:53'!assertSupplier1ImportedCorrectly	| supplier identification anAddress aCustomer |		identification := Identification ofType: 'D' number: '123'.	supplier := supplierSystem		supplierIdentifiedAs: identification		ifNone: [ self fail ].	self assert: supplier name equals: 'Supplier1'.	self assert: (supplier isIdentifiedAs: identification).		identification := Identification ofType: 'D' number: '22333444'.	aCustomer := supplier customerIdentifiedAs: identification.	self assert: (aCustomer isIdentifiedAs: identification).	self assert: aCustomer firstName equals: 'Pepe'.	self assert: aCustomer lastName equals: 'Sanchez'.		identification := Identification ofType: 'D' number: '5456774'.	aCustomer := supplier customerIdentifiedAs: identification.	self assert: (aCustomer isIdentifiedAs: identification).	self assert: aCustomer firstName equals: 'Juan'.	self assert: aCustomer lastName equals: 'Martin'.		anAddress := supplier addressAt: 'San Martin' at: 3322.	self assert: (anAddress isAt: 'San Martin' at: 3322).	self assert: anAddress town equals: 'Olivos'.	self assert: anAddress zipCode equals: 1636.	self assert: anAddress province equals: 'BsAs'! !!SupplierImporterTest methodsFor: 'tests' stamp: 'GustavoJuanCairo 11/16/2017 21:12'!assertSuppliersNotImported	self assert: (self numberOfSuppliers) equals: 0! !ERPSystem subclass: #SupplierSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!SupplierSystem methodsFor: 'persistance' stamp: 'GustavoJuanCairo 11/20/2017 22:37'!supplierIdentifiedAs: anId ifNone: anObject 	self subclassResponsibility ! !!SupplierSystem methodsFor: 'persistance' stamp: 'GustavoJuanCairo 11/16/2017 20:07'!allSuppliers	self subclassResponsibility ! !SupplierSystem subclass: #PersistentSupplierSystem	instanceVariableNames: 'session'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!PersistentSupplierSystem methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/20/2017 22:40'!supplierMapping	^ ClassMapping		withDefaultTableNameFor: Supplier		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #name)				with: (EmbededMapping withDefaultFieldNameFor: #identification)				with: (OneToManyMapping withDefaultFieldNameFor: #customers ofType: Customer)				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address))! !!PersistentSupplierSystem methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/16/2017 20:01'!addressMapping	^ ClassMapping		withDefaultTableNameFor: Address		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #streetName)				with: (EmbededMapping withDefaultFieldNameFor: #streetNumber)				with: (EmbededMapping withDefaultFieldNameFor: #town)				with: (EmbededMapping withDefaultFieldNameFor: #zipCode)				with: (EmbededMapping withDefaultFieldNameFor: #province))! !!PersistentSupplierSystem methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/16/2017 20:01'!startUp	session open.	session beginTransaction! !!PersistentSupplierSystem methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/16/2017 20:01'!shutDown	session commit.	session close! !!PersistentSupplierSystem methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/20/2017 22:37'!customerMapping	^ ClassMapping		withDefaultTableNameFor: Customer		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #firstName)				with: (EmbededMapping withDefaultFieldNameFor: #lastName)				with: (EmbededMapping withDefaultFieldNameFor: #identification)				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address))! !!PersistentSupplierSystem methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/16/2017 20:20'!initializeSession	session := DataBaseSession		for: (Array with: self addressMapping with: self customerMapping with: self supplierMapping)! !!PersistentSupplierSystem methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/16/2017 20:22'!persist: aSupplier	session persist: aSupplier ! !!PersistentSupplierSystem methodsFor: 'importing' stamp: 'GustavoJuanCairo 11/16/2017 20:01'!initialize	super initialize.	self initializeSession ! !!PersistentSupplierSystem methodsFor: 'tests' stamp: 'GustavoJuanCairo 11/16/2017 20:09'!allSuppliers	^ session selectAllOfType: Supplier! !!PersistentSupplierSystem methodsFor: 'tests' stamp: 'GustavoJuanCairo 11/20/2017 22:38'!supplierIdentifiedAs: anId ifNone: noneBlock	| suppliers |	suppliers := session		select: [ :aSupplier | aSupplier isIdentifiedAs: anId ]		ofType: Supplier.	suppliers size < 1		ifTrue: noneBlock.	^ suppliers anyOne! !CustomerSystem subclass: #TransientCustomerSystem	instanceVariableNames: 'customers'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!TransientCustomerSystem methodsFor: 'connection open/close' stamp: 'SebastianTaboh 11/13/2017 21:10'!shutDown	! !!TransientCustomerSystem methodsFor: 'accessing' stamp: 'SebastianTaboh 11/13/2017 21:05'!allCustomers		^ customers copy ! !!TransientCustomerSystem methodsFor: 'Accessing' stamp: 'GustavoJuanCairo 11/20/2017 22:36'!customerIdentifiedAs: anId ifNone: noneBlock	^ customers		detect: [ :aCustomer | aCustomer isIdentifiedAs: anId ]		ifFound: [ :aCustomer | aCustomer ]		ifNone: noneBlock! !!TransientCustomerSystem methodsFor: 'instance initialization' stamp: 'SebastianTaboh 11/13/2017 21:05'!initialize	super initialize.	customers := OrderedCollection new! !!TransientCustomerSystem methodsFor: 'instance initialization' stamp: 'SebastianTaboh 11/13/2017 21:05'!persist: aCustomer	customers add: aCustomer! !!TransientCustomerSystem methodsFor: 'instance initialization' stamp: 'SebastianTaboh 11/13/2017 21:04'!startUp	! !SupplierSystem subclass: #TransientSupplierSystem	instanceVariableNames: 'suppliers'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!TransientSupplierSystem methodsFor: 'accessing' stamp: 'GustavoJuanCairo 11/16/2017 20:24'!allSuppliers		^ suppliers copy ! !!TransientSupplierSystem methodsFor: 'instance initialization' stamp: 'GustavoJuanCairo 11/16/2017 20:24'!initialize	super initialize.	suppliers := OrderedCollection new! !!TransientSupplierSystem methodsFor: 'instance initialization' stamp: 'GustavoJuanCairo 11/16/2017 20:24'!persist: aSupplier	suppliers add: aSupplier! !!TransientSupplierSystem methodsFor: 'instance initialization' stamp: 'GustavoJuanCairo 11/16/2017 20:00'!startUp	! !!TransientSupplierSystem methodsFor: 'connection open/close' stamp: 'GustavoJuanCairo 11/16/2017 20:00'!shutDown	! !!TransientSupplierSystem methodsFor: 'Accessing' stamp: 'GustavoJuanCairo 11/20/2017 22:40'!supplierIdentifiedAs: anId ifNone: noneBlock	^ suppliers		detect: [ :aSupplier | aSupplier isIdentifiedAs: anId ]		ifFound: [ :aSupplier | aSupplier ]		ifNone: noneBlock! !Object subclass: #ClassMapping	instanceVariableNames: 'mappedClass mappings tableName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-PersistanceModel'!!ClassMapping methodsFor: 'table' stamp: 'HernanWilkinson 10/31/2016 23:25'!tableName		^tableName ! !!ClassMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 00:40'!map: anObject using: aDataBaseSession	| record |	self toDo: 'se puede optimizar usando array para registros y guardando definicion de tabla una vez'.	record := Dictionary new.		self mapIdOf: anObject into: record using: aDataBaseSession.	self mapEmbededOf: anObject into: record.	"agrego aca el registro y no luego de mapear el id para que lo agrege completo. Lo agrego antes de mapear las rel one to many 	porque si usuara una db de verdad habria foreign key constrain"	aDataBaseSession add: record on: self tableName.	self mapOneToManyRelationshipsOf: anObject using: aDataBaseSession! !!ClassMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 00:42'!unmap: aRecord using: aDataBaseSession	| unMappedObject |	unMappedObject := mappedClass basicNew.	self unmapIdOf: aRecord into: unMappedObject.	self unmap: aRecord into: unMappedObject using: aDataBaseSession.	^ unMappedObject! !!ClassMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:25'!initializeFor: aClass into: aTableName mappingAll: aCollectionOfMappings	mappedClass := aClass.	tableName := aTableName.	mappings := aCollectionOfMappings ! !!ClassMapping methodsFor: 'testing' stamp: 'HernanWilkinson 10/31/2016 23:02'!isFor: aClass	^mappedClass = aClass! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	mappings do: [ :aMapping | aMapping mapOneToManyRelationshipsOf: anObject using: aDataBaseSession ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:43'!unmapIdOf: aRecord into: unMappedObject	unMappedObject instVarNamed: #id put: (aRecord at: #id)! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapEmbededOf: anObject into: record	mappings do: [ :aMapping | aMapping embeded: anObject into: record ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:43'!unmap: aRecord into: unMappedObject using: aDataBaseSession	mappings do: [ :aMapping | aMapping unmap: aRecord into: unMappedObject using: aDataBaseSession ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapIdOf: anObject into: record using: aDataBaseSession	| newId |	newId := aDataBaseSession newIdFor: anObject.	anObject instVarNamed: #id put: newId.	record at: #id put: newId! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ClassMapping class	instanceVariableNames: ''!!ClassMapping class methodsFor: 'assertions' stamp: 'GustavoJuanCairo 11/20/2017 20:46'!assertHasIdInstanceVariable: aClass 		(aClass classThatDefinesInstanceVariable: #id) ifNil: [ self error: ('<1s> has no id instance variable' expandMacrosWith: aClass name) ]! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 23:41'!assertValidTableName: aTableName	aTableName trimBoth isEmpty ifTrue: [ self error: 'Table name can not be empty' ]! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 19:26'!assertValidMappings: aCollectionOfMappings for: aClass 	self toDo: 'Lo mejor seria recolectar todos los erroes de mapeo y no parar en el primero'.	aCollectionOfMappings do: [ :aMapping | aMapping assertIsValidFor: aClass ]	! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:23'!withDefaultTableNameFor: aClass mappingAll: aCollectionOfMappings	^self for: aClass into: (self defaultTableNameFor: aClass) mappingAll: aCollectionOfMappings		! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 00:44'!defaultTableNameFor: aClass		^aClass name asString! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:24'!for: aClass into: aTableName mappingAll: aCollectionOfMappings	self assertValidTableName: aTableName.	self assertHasIdInstanceVariable: aClass.	self assertValidMappings: aCollectionOfMappings for: aClass.		^self new initializeFor: aClass into: aTableName mappingAll: aCollectionOfMappings		! !Object subclass: #DataBaseSession	instanceVariableNames: 'configuration tables id cache'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-PersistanceModel'!!DataBaseSession methodsFor: 'persistance' stamp: 'HernanWilkinson 11/1/2016 01:28'!persist: anObject	| mapper |		self assertInTransaction.	self delay.		mapper := self mapperFor: anObject class.	mapper map: anObject using: self.		self addToCache: anObject ! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:16'!unmapRecordIdentifiedAs: anId ofType: aClass	| record table mapper |	mapper := self mapperFor: aClass.	table := self tableNamed: mapper tableName.	record := table at: id ifAbsent: [ self error: ('Object identified as <1s> does not exist' expandMacrosWith: anId printString) ].		^ mapper unmap: record using: self! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:14'!mapperFor: aClass	self toDo: 'se puede mejorar performanco usando un dictionary'.	^configuration		detect: [ :aClassMapper | aClassMapper isFor: aClass ] 		ifNone: [ self error: ('There is no mapper for <1s>' expandMacrosWith: aClass name) ]! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:15'!relatedOfType: aRelatedClass for: anOwner	| table relatedIds |		table := self relationTableFor: anOwner class relatedTo: aRelatedClass.	relatedIds := table at: (self idOf: anOwner) ifAbsent: [ ^#() ].		^relatedIds collect: [ :aRelatedId | self objectIdentifiedAs: aRelatedId ofType: aRelatedClass ]		! !!DataBaseSession methodsFor: 'persistence - private' stamp: 'HernanWilkinson 10/28/2016 16:35'!defineIdOf: anObject	anObject instVarNamed: 'id' put: (self newIdFor: anObject).! !!DataBaseSession methodsFor: 'persistence - private' stamp: 'HernanWilkinson 10/28/2016 16:41'!delay	(Delay forMilliseconds: 100) wait! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:36'!open	self assertIsClose.		tables := Dictionary new.	! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:37'!assertIsClose		tables isNil ifFalse: [ self error: 'Session must be close' ]! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 22:14'!close	self assertIsOpen.		tables := nil! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:36'!assertIsOpen		tables isNil ifTrue: [ self error: 'Session must be open to colaborate with it' ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:06'!relatedIdOwnedBy: anOwner on: table	^ table at: (self idOf: anOwner) ifAbsentPut: [ Set new ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:10'!relatedIdsOwnedBy: anOwner forType: aRelatedClass	| relatedIds table |	table := self relationTableFor: anOwner class relatedTo: aRelatedClass.	relatedIds := self relatedIdOwnedBy: anOwner on: table.		^ relatedIds! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:03'!add: aRecord on: aTableName	| table existingRecord |	table := self tableNamed: aTableName.	existingRecord := table at: (self recordId: aRecord) ifAbsentPut: [ aRecord ].	existingRecord == aRecord ifFalse: [ self error: 'Duplicated primary key' ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:05'!assertRelationOwnedBy: anOwner isUniqueFor: aRelated identifiedAs: relatedId in: relatedIds	(relatedIds includes: relatedId) ifTrue: [ self signalRelationAlreadyExistBetween: anOwner and: aRelated ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:03'!addRelated: aRelated ownedBy: anOwner	| relatedIds relatedId |	relatedIds := self relatedIdsOwnedBy: anOwner forType: aRelated class.	relatedId := aRelated instVarNamed: #id.	self assertRelationOwnedBy: anOwner isUniqueFor: aRelated identifiedAs: relatedId in: relatedIds.		relatedIds add: relatedId! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:00'!signalRelationAlreadyExistBetween: anOwner and: aRelated 	self error: ('Relation between id <1s> of type <2s> and id <3s> of type <4s> already exist'		expandMacrosWith: (self idOf: anOwner) printString		with: anOwner class name		with: (self idOf: aRelated) printString		with: aRelated class name)! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:27'!addToCache: anObject 	cache at: (self idOf: anObject) put: anObject ! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 01:12'!relationTableNameOwnedBy: anOwnerClass relatedTo: aRelatedClass	| ownerClassMapper relatedClassMapper |		ownerClassMapper := self mapperFor: anOwnerClass.	relatedClassMapper := self mapperFor: aRelatedClass.		^ownerClassMapper tableName,'_', relatedClassMapper tableName asPlural.! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 01:12'!relationTableFor: anOwnerClass relatedTo: aRelatedClass	| relationTableName table |	relationTableName := self relationTableNameOwnedBy: anOwnerClass relatedTo: aRelatedClass.	table := self tableNamed: relationTableName.		^ table! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 00:48'!tableNamed: aTableName	^ tables at: aTableName ifAbsentPut: [ Dictionary new ]! !!DataBaseSession methodsFor: 'selecting - private' stamp: 'HernanWilkinson 11/1/2016 01:28'!addInto: selected theOnesThatHold: aCondition unmapping: record with: mapper	| recordId aClassInstance |	recordId := self recordId: record.	aClassInstance := cache at: recordId ifAbsent: [ mapper unmap: record using: self ].	(aCondition value: aClassInstance) ifTrue: [ 		self addToCache: aClassInstance.		selected add: aClassInstance ].		^ selected! !!DataBaseSession methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 22:55'!initializeFor: aConfiguration	configuration := aConfiguration.	id := 0.	tables := nil.	cache := nil.! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 11/1/2016 01:26'!select: aCondition ofType: aClass	| mapper table |	self assertInTransaction.	self delay.		mapper := self mapperFor: aClass.	table := tables at: mapper tableName ifAbsent: [ ^ #() ].		^ table inject: OrderedCollection new into: [ :selected :record | self addInto: selected theOnesThatHold: aCondition unmapping: record with: mapper ]! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 11/1/2016 01:15'!objectIdentifiedAs: anId ofType: aClass	self assertInTransaction.	self delay.		^ cache at: anId ifAbsentPut: [ self unmapRecordIdentifiedAs: anId ofType: aClass ]! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 10/31/2016 22:17'!selectAllOfType: aClass 		^self select: [ :anObject | true ] ofType: aClass! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 10/28/2016 16:35'!newIdFor: anObject	id := id + 1.	^id! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 11/1/2016 01:00'!idOf: anObject	^anObject instVarNamed: #id! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 11/1/2016 01:04'!recordId: aRecord	^aRecord at: #id! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:55'!assertInTransaction		cache isNil ifTrue: [ self error: 'There is no transaction currently' ]! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:55'!assertNotInTransasction		cache notNil ifTrue: [ self error: 'There is an open transaction already' ]! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:57'!beginTransaction	self assertIsOpen.	self assertNotInTransasction.		cache := WeakKeyDictionary new.	! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:57'!commit		self assertInTransaction.		cache := nil! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DataBaseSession class	instanceVariableNames: ''!!DataBaseSession class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/28/2016 13:07'!for: aConfiguration	^self new initializeFor: aConfiguration! !Object subclass: #Mapping	instanceVariableNames: 'instanceVariableName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-PersistanceModel'!!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!embeded: anObject into: aRecord	self subclassResponsibility! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	self subclassResponsibility! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!unmap: aRecord into: anObject using: aDataBaseSession	self subclassResponsibility! !!Mapping methodsFor: 'assertions' stamp: 'GustavoJuanCairo 11/20/2017 20:47'!assertIsValidFor: aClass 	(aClass classThatDefinesInstanceVariable: instanceVariableName) ifNil: [ 		self error: ('Invalid mapping for <1s> in class <2s>' expandMacrosWith: instanceVariableName with: aClass name) ] ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Mapping class	instanceVariableNames: ''!!Mapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 01:32'!defaultFieldNameFor: anInstanceVariableName	^anInstanceVariableName asString! !!Mapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 23:41'!assertValidFieldName: aFieldName	aFieldName trimBoth isEmpty ifTrue: [ self error: 'Field name can not be empty' ]! !Mapping subclass: #EmbededMapping	instanceVariableNames: 'fieldName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-PersistanceModel'!!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:31'!embeded: anObject into: aRecord	aRecord at: fieldName put: (anObject instVarNamed: instanceVariableName) ! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 21:23'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession 		! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:31'!unmap: aRecord into: anObject using: aDataBaseSession 	anObject instVarNamed: instanceVariableName put: (aRecord at: fieldName)! !!EmbededMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:30'!initializeFor: anInstanceVariableName into: aFieldName	instanceVariableName := anInstanceVariableName.	fieldName := aFieldName ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EmbededMapping class	instanceVariableNames: ''!!EmbededMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:30'!for: anInstanceVariableName into: aFieldName	^self new initializeFor: anInstanceVariableName into: aFieldName ! !!EmbededMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:29'!withDefaultFieldNameFor: anInstanceVariableName	^self for: anInstanceVariableName into: (self defaultFieldNameFor: anInstanceVariableName)! !Mapping subclass: #OneToManyMapping	instanceVariableNames: 'relatedType fieldName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-PersistanceModel'!!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:35'!createRelationCollectionOn: aDataBaseSession ownedBy: anObject	^ OneToManySet on: aDataBaseSession ownedBy: anObject! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 21:16'!embeded: anObject into: aRecord	! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:37'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	| oldCollection newCollection |	newCollection := self createRelationCollectionOn: aDataBaseSession ownedBy: anObject.	oldCollection := anObject instVarNamed: instanceVariableName.		newCollection addAll: oldCollection.	anObject instVarNamed: instanceVariableName put: newCollection! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:37'!unmap: aRecord into: anObject using: aDataBaseSession	| newCollection related |	related := aDataBaseSession relatedOfType: relatedType for: anObject.	newCollection := self createRelationCollectionOn: aDataBaseSession ownedBy: anObject.	newCollection addAllNotPersisting: related.	anObject instVarNamed: instanceVariableName put: newCollection! !!OneToManyMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:34'!initializeFor: anInstanceVariableName into: aFieldName ofType: aClass	instanceVariableName := anInstanceVariableName.	fieldName := aFieldName.	relatedType := aClass ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OneToManyMapping class	instanceVariableNames: ''!!OneToManyMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:40'!for: anInstanceVariableName into: aFieldName ofType: aClass	self assertValidFieldName: aFieldName.		^self new initializeFor: anInstanceVariableName into: aFieldName ofType: aClass! !!OneToManyMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:32'!withDefaultFieldNameFor: anInstanceVariableName ofType: aClass	^self for: anInstanceVariableName into: (self defaultFieldNameFor: anInstanceVariableName) ofType: aClass! !Set subclass: #OneToManySet	instanceVariableNames: 'session owner'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-PersistanceModel'!!OneToManySet methodsFor: 'initialization' stamp: 'HernanWilkinson 11/1/2016 00:11'!initializeOn: aDataBaseSession ownedBy: anOwner		session := aDataBaseSession.	owner := anOwner ! !!OneToManySet methodsFor: 'removing' stamp: 'HernanWilkinson 10/31/2016 21:35'!remove: anObject ifAbsent: anAbsentBlock	self shouldBeImplemented ! !!OneToManySet methodsFor: 'adding' stamp: 'HernanWilkinson 11/1/2016 00:03'!addAllNotPersisting: aCollection 		^aCollection do: [ :anObjectToAdd | super add: anObjectToAdd ]! !!OneToManySet methodsFor: 'adding' stamp: 'HernanWilkinson 11/1/2016 00:11'!add: anObject	session persist: anObject.	session addRelated: anObject ownedBy: owner.		super add: anObject.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OneToManySet class	instanceVariableNames: ''!!OneToManySet class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 00:11'!on: aDataBaseSession ownedBy: anOwner		^self new initializeOn: aDataBaseSession ownedBy: anOwner ! !'From Pharo6.0 of 13 May 2016 [Latest update: #60520] on 20 November 2017 at 11:46:40.363206 pm'!!String methodsFor: '*10Pines-C17-1' stamp: 'HernanWilkinson 10/31/2016 23:57'!asPlural		^self last = $s 		ifTrue: [ self, 'es' ]		ifFalse: [ self, 's' ]! !'From Pharo6.0 of 13 May 2016 [Latest update: #60520] on 20 November 2017 at 11:46:40.363822 pm'!!Object methodsFor: '*10Pines-C17-1' stamp: 'HernanWilkinson 10/31/2016 19:27'!toDo: aString 	! !